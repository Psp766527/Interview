<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🚀 Java Stream API – Interactive Learning Experience</title>
  <style>
    :root{
      --bg:#0b1220; --card:#121a2b; --muted:#94a3b8; --text:#e6edf3; --accent:#60a5fa; --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
      --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }
    
    *{box-sizing:border-box}
    
    body{
      margin:0; 
      font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; 
      background:var(--bg); 
      color:var(--text); 
      line-height:1.6;
      overflow-x: hidden;
    }
    
    /* Animated background particles */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    
    .particle {
      position: absolute;
      background: radial-gradient(circle, rgba(96,165,250,0.3) 0%, transparent 70%);
      border-radius: 50%;
      animation: float 6s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 0.8; }
    }
    
    /* Cinematic header with parallax */
    header{
      padding:60px 24px; 
      text-align:center; 
      background: linear-gradient(135deg, rgba(96,165,250,.2) 0%, rgba(139,92,246,.2) 50%, rgba(236,72,153,.2) 100%);
      position: relative;
      overflow: hidden;
    }
    
    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(96,165,250,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
      animation: gridMove 20s linear infinite;
    }
    
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(10px, 10px); }
    }
    
    h1{
      margin:0 0 8px; 
      font-size:clamp(24px,3vw,36px);
      background: var(--gradient-1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: glow 2s ease-in-out infinite alternate;
      position: relative;
      z-index: 1;
    }
    
    @keyframes glow {
      from { filter: drop-shadow(0 0 5px rgba(96,165,250,0.5)); }
      to { filter: drop-shadow(0 0 20px rgba(96,165,250,0.8)); }
    }
    
    h2{
      margin:28px 0 8px; 
      font-size:clamp(18px,2.2vw,24px); 
      color:#fff;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    h2:hover {
      transform: translateX(10px);
      color: var(--accent);
    }
    
    h2::before {
      content: '';
      position: absolute;
      left: -20px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 0;
      background: var(--gradient-2);
      transition: height 0.3s ease;
    }
    
    h2:hover::before {
      height: 100%;
      
    }
    
    h3{
      margin:18px 0 8px; 
      font-size:18px; 
      color:#fff;
      transition: all 0.3s ease;
    }
    
    h3:hover {
      color: var(--accent);
      transform: scale(1.02);
    }
    
    p.lead{
      color:var(--muted); 
      margin:0 auto; 
      max-width:900px;
      font-size: 1.1rem;
      animation: fadeInUp 1s ease-out;
    }
    
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    main{
      max-width:1100px; 
      margin:24px auto 60px; 
      padding:0 16px;
    }
    
    /* Enhanced cards with hover effects */
    .card{
      background:var(--card); 
      border:1px solid rgba(148,163,184,.15); 
      border-radius:16px; 
      padding:20px; 
      box-shadow:0 10px 30px rgba(0,0,0,.25); 
      margin-bottom:18px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(96,165,250,0.1), transparent);
      transition: left 0.5s ease;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 40px rgba(0,0,0,.4);
      border-color: var(--accent);
    }
    
    .card:hover::before {
      left: 100%;
    }
    
    .grid{display:grid; gap:16px}
    @media(min-width:900px){.grid.cols-2{grid-template-columns:1fr 1fr}}
    @media(min-width:1200px){.grid.cols-3{grid-template-columns:1fr 1fr 1fr}}
    @media(min-width:1200px){.grid.cols-4{grid-template-columns:1fr 1fr 1fr 1fr}}
    
    /* Interactive code blocks */
    code, pre{
      background:#0a1020; 
      color:#e6edf3; 
      border:1px solid rgba(148,163,184,.15); 
      border-radius:10px;
      transition: all 0.3s ease;
    }
    
    code{
      padding:.15rem .35rem;
      cursor: pointer;
    }
    
    code:hover {
      background: #0f172a;
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    pre{
      padding:14px; 
      overflow:auto;
      position: relative;
    }
    
    pre:hover {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(96,165,250,0.2);
    }
    
    /* Interactive table */
    table{
      width:100%; 
      border-collapse:separate; 
      border-spacing:0; 
      overflow:hidden; 
      border-radius:14px; 
      border:1px solid rgba(148,163,184,.15);
      transition: all 0.3s ease;
    }
    
    table:hover {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(96,165,250,0.1);
    }
    
    th, td{
      padding:10px 12px; 
      border-bottom:1px solid rgba(148,163,184,.12); 
      vertical-align:top;
      transition: all 0.3s ease;
    }
    
    th{
      background:#0f172a; 
      text-align:left;
      cursor: pointer;
    }
    
    th:hover {
      background: #1e293b;
      color: var(--accent);
    }
    
    tr:hover td {
      background: rgba(96,165,250,0.05);
    }
    
    tr:last-child td{border-bottom:none}
    
    /* Interactive elements */
    .tag{
      display:inline-block; 
      padding:.15rem .5rem; 
      border-radius:999px; 
      font-size:.8rem; 
      border:1px solid rgba(148,163,184,.25); 
      color:#cbd5e1;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .tag:hover {
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(96,165,250,0.3);
    }
    
    .ok{border-color:#14532d; color:#86efac}
    .warn{border-color:#7c2d12; color:#fdba74}
    .muted{color:var(--muted)}
    .small{font-size:.92rem}
    .section-note{margin-top:6px; color:var(--muted)}
    
    .kbd{
      border:1px solid #2b3a55; 
      padding:.1rem .35rem; 
      border-radius:6px; 
      background:#0d1528; 
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      transition: all 0.3s ease;
    }
    
    .kbd:hover {
      background: #1e293b;
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .svgwrap{display:flex; justify-content:center; padding:12px}
    
    /* Interactive quiz styles */
    .quiz-container {
      background: var(--card);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid rgba(148,163,184,.15);
    }
    
    .quiz-question {
      font-size: 1.1rem;
      margin-bottom: 15px;
      color: #fff;
    }
    
    .quiz-options {
      display: grid;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .quiz-option {
      padding: 12px;
      background: #0f172a;
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .quiz-option:hover {
      background: #1e293b;
      border-color: var(--accent);
      transform: translateX(5px);
    }
    
    .quiz-option.selected {
      background: rgba(96,165,250,0.2);
      border-color: var(--accent);
    }
    
    .quiz-option.correct {
      background: rgba(34,197,94,0.2);
      border-color: var(--ok);
    }
    
    .quiz-option.incorrect {
      background: rgba(239,68,68,0.2);
      border-color: var(--danger);
    }
    
    .quiz-feedback {
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      display: none;
    }
    
    .quiz-feedback.show {
      display: block;
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .quiz-feedback.correct {
      background: rgba(34,197,94,0.1);
      border: 1px solid var(--ok);
      color: var(--ok);
    }
    
    .quiz-feedback.incorrect {
      background: rgba(239,68,68,0.1);
      border: 1px solid var(--danger);
      color: var(--danger);
    }
    
    /* Code playground */
    .code-playground {
      background: #0a1020;
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .code-editor {
      width: 100%;
      min-height: 200px;
      background: #0a1020;
      color: #e6edf3;
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 8px;
      padding: 15px;
      font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
      font-size: 14px;
      resize: vertical;
    }
    
    .run-button {
      background: var(--gradient-1);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
      transition: all 0.3s ease;
    }
    
    .run-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(96,165,250,0.4);
    }
    
    .output {
      background: #0f172a;
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
      min-height: 50px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    
    /* Progress tracking */
    .progress-container {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card);
      border: 1px solid rgba(148,163,184,.15);
      border-radius: 12px;
      padding: 15px;
      min-width: 200px;
      z-index: 1000;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #0f172a;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--gradient-1);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    /* Interactive stream visualization */
    .stream-visualization {
      background: var(--card);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid rgba(148,163,184,.15);
    }
    
    .stream-step {
      display: flex;
      align-items: center;
      margin: 15px 0;
      padding: 15px;
      background: #0f172a;
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,.15);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .stream-step:hover {
      background: #1e293b;
      border-color: var(--accent);
      transform: translateX(5px);
    }
    
    .stream-step.active {
      background: rgba(96,165,250,0.1);
      border-color: var(--accent);
    }
    
    .stream-arrow {
      margin: 0 15px;
      color: var(--accent);
      font-size: 1.5rem;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    /* Achievement system */
    .achievement {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--gradient-1);
      color: white;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      z-index: 2000;
      display: none;
      animation: achievementPop 0.5s ease;
    }
    
    @keyframes achievementPop {
      0% { transform: translate(-50%, -50%) scale(0); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .achievement.show {
      display: block;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .progress-container {
        position: relative;
        top: auto;
        right: auto;
        margin: 20px 0;
      }
      
      .grid.cols-2,
      .grid.cols-3,
      .grid.cols-4 {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Animated background particles -->
  <div class="particles" id="particles"></div>
  
  <!-- Progress tracking -->
  <div class="progress-container">
    <h4>🎯 Learning Progress</h4>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <p id="progressText">0% Complete</p>
    <div id="achievements"></div>
  </div>
  
  <!-- Achievement popup -->
  <div class="achievement" id="achievementPopup">
    <h3>🏆 Achievement Unlocked!</h3>
    <p id="achievementText"></p>
  </div>

  <header>
    <h1>🚀 Java Stream API – Interactive Learning Experience</h1>
    <p class="lead">🎯 Master Stream API with interactive quizzes, live code playground, and cinematic visual effects. Learn through hands-on practice and visual memory aids!</p>
  </header>

  <main>
    <!-- Memory Tricks & Mnemonics -->
    <section class="card">
      <h2>🧠 Memory Tricks & Mnemonics</h2>
      <div class="grid cols-2">
        <div>
          <h3>🎯 Core Memory Hacks</h3>
          <ul>
            <li><strong>LIFT</strong> - <span class="muted">Lazy Intermediate, Fast Terminal</span></li>
            <li><strong>MAP-FILTER-SORT</strong> - <span class="muted">Most common intermediate ops order</span></li>
            <li><strong>COLLECT-COUNT-REDUCE</strong> - <span class="muted">Most common terminal ops</span></li>
            <li><strong>PEEK = DEBUG</strong> - <span class="muted">Peek is for debugging, not transformation</span></li>
          </ul>
          <h3>🔑 Key Differences</h3>
          <ul>
            <li><strong>map vs flatMap</strong> - <span class="muted">1→1 vs 1→Many (flatten)</span></li>
            <li><strong>findFirst vs findAny</strong> - <span class="muted">Ordered vs Any (parallel friendly)</span></li>
            <li><strong>reduce vs collect</strong> - <span class="muted">Immutable vs Mutable reduction</span></li>
          </ul>
        </div>
        <div>
          <h3>⚡ Performance Tips</h3>
          <ul>
            <li><strong>Primitive Streams</strong> - <span class="muted">Use mapToInt/ToLong/ToDouble (no boxing)</span></li>
            <li><strong>Short-circuiting</strong> - <span class="muted">limit, findFirst, anyMatch stop early</span></li>
            <li><strong>Parallel Streams</strong> - <span class="muted">Only for CPU-bound, large data</span></li>
            <li><strong>Ordering Matters</strong> - <span class="muted">filter before map (reduce elements)</span></li>
          </ul>
          <h3>🚨 Common Pitfalls</h3>
          <ul>
            <li><strong>Stream consumed twice</strong> - <span class="muted">Create new stream each time</span></li>
            <li><strong>Null handling</strong> - <span class="muted">filter(Objects::nonNull)</span></li>
            <li><strong>Side effects in parallel</strong> - <span class="muted">Avoid shared state</span></li>
          </ul>
        </div>
      </div>
      
      <!-- Interactive Quiz 1 -->
      <div class="quiz-container">
        <h3>🎯 Quick Knowledge Check</h3>
        <div class="quiz-question">What does LIFT stand for in Stream API memory tricks?</div>
        <div class="quiz-options">
          <div class="quiz-option" data-correct="true">Lazy Intermediate, Fast Terminal</div>
          <div class="quiz-option" data-correct="false">Lazy Input, Fast Transformation</div>
          <div class="quiz-option" data-correct="false">Linear Input, Fast Terminal</div>
          <div class="quiz-option" data-correct="false">Lazy Iterator, Fast Traversal</div>
        </div>
        <div class="quiz-feedback">
          <p></p>
        </div>
      </div>
    </section>

    <!-- Interactive Stream Visualization -->
    <section class="card">
      <h2>🎨 Interactive Stream Flow Visualization</h2>
      
      <div class="stream-visualization">
        <h3>🔄 Click to see Stream Pipeline in Action</h3>
        <div class="stream-step" data-step="source">
          <span class="stream-arrow">📊</span>
          <div>
            <strong>Source:</strong> List&lt;Employee&gt; employees
            <br><small>Data: [Alice(25), Bob(30), Charlie(35), Diana(28)]</small>
          </div>
        </div>
        
        <div class="stream-arrow">↓</div>
        
        <div class="stream-step" data-step="filter">
          <span class="stream-arrow">🔍</span>
          <div>
            <strong>Filter:</strong> .filter(emp -> emp.getAge() > 25)
            <br><small>Result: [Bob(30), Charlie(35), Diana(28)]</small>
          </div>
        </div>
        
        <div class="stream-arrow">↓</div>
        
        <div class="stream-step" data-step="map">
          <span class="stream-arrow">🔄</span>
          <div>
            <strong>Map:</strong> .map(Employee::getName)
            <br><small>Result: ["Bob", "Charlie", "Diana"]</small>
          </div>
        </div>
        
        <div class="stream-arrow">↓</div>
        
        <div class="stream-step" data-step="collect">
          <span class="stream-arrow">📦</span>
          <div>
            <strong>Collect:</strong> .collect(toList())
            <br><small>Final Result: List&lt;String&gt; names</small>
          </div>
        </div>
      </div>
      
      <!-- Code Playground -->
      <div class="code-playground">
        <h3>💻 Live Code Playground</h3>
        <p>Try this example and modify it to see different results:</p>
        <textarea class="code-editor" id="codeEditor">// Employee class
class Employee {
    private String name;
    private int age;
    
    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}

// Sample data
List&lt;Employee&gt; employees = Arrays.asList(
    new Employee("Alice", 25),
    new Employee("Bob", 30),
    new Employee("Charlie", 35),
    new Employee("Diana", 28)
);

// Stream pipeline
List&lt;String&gt; names = employees.stream()
    .filter(emp -&gt; emp.getAge() &gt; 25)
    .map(Employee::getName)
    .collect(Collectors.toList());

System.out.println("Names: " + names);</textarea>
        <button class="run-button" onclick="runCode()">🚀 Run Code</button>
        <div class="output" id="codeOutput">Click "Run Code" to see the output...</div>
      </div>
      
      <p class="section-note small">🎯 <strong>Memory Rule:</strong> Intermediate ops are lazy (build a pipeline). Terminal ops execute the pipeline. Think: Recipe vs Cooking!</p>
    </section>

    <!-- Interview Questions with Interactive Quizzes -->
    <section class="card">
      <h2>🎯 Interview Questions – Battle-Tested Tips</h2>
      
      <!-- Interactive Quiz 2 -->
      <div class="quiz-container">
        <h3>🔥 Hot Interview Topics Quiz</h3>
        <div class="quiz-question">What's the key difference between map() and flatMap()?</div>
        <div class="quiz-options">
          <div class="quiz-option" data-correct="false">map() is faster than flatMap()</div>
          <div class="quiz-option" data-correct="true">map() transforms 1→1, flatMap() transforms 1→Many and flattens</div>
          <div class="quiz-option" data-correct="false">flatMap() is only for primitive types</div>
          <div class="quiz-option" data-correct="false">There's no difference, they're interchangeable</div>
        </div>
        <div class="quiz-feedback">
          <p></p>
        </div>
      </div>
      
      <div class="grid cols-2">
        <div>
          <h3>🔥 Hot Interview Topics</h3>
          <ul>
            <li><strong>map vs flatMap?</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> map = 1→1, flatMap = 1→Many (flatten)<br>
              🎯 <strong>Tip:</strong> Use flatMap for nested collections, map for transformations<br>
              ⚠️ <strong>Pitfall:</strong> flatMap returns Stream&lt;R&gt;, not Collection&lt;R&gt;</span></li>
            
            <li><strong>filter vs map?</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> filter = gatekeeper, map = transformer<br>
              🎯 <strong>Tip:</strong> filter first to reduce elements, then map<br>
              ⚠️ <strong>Pitfall:</strong> filter changes count, map changes type</span></li>
            
            <li><strong>Intermediate vs Terminal</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> LIFT = Lazy Intermediate, Fast Terminal<br>
              🎯 <strong>Tip:</strong> Chain intermediates, end with terminal<br>
              ⚠️ <strong>Pitfall:</strong> Stream consumed after terminal operation</span></li>
          </ul>
          
          <h3>⚡ Performance & Operations</h3>
          <ul>
            <li><strong>reduce vs collect</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> reduce = immutable, collect = mutable<br>
              🎯 <strong>Tip:</strong> Use collect for complex aggregations<br>
              ⚠️ <strong>Pitfall:</strong> reduce with mutable accumulator is dangerous</span></li>
            
            <li><strong>findFirst vs findAny</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> First = ordered, Any = parallel-friendly<br>
              🎯 <strong>Tip:</strong> Use findAny in parallel streams for better performance<br>
              ⚠️ <strong>Pitfall:</strong> findFirst in parallel may be slower</span></li>
            
            <li><strong>Short‑circuiting Operations</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> LIMIT = limit, findFirst, anyMatch, allMatch<br>
              🎯 <strong>Tip:</strong> Use for early termination<br>
              ⚠️ <strong>Pitfall:</strong> Not all operations are short-circuiting</span></li>
          </ul>
        </div>
        
        <div>
          <h3>🚀 Advanced & Parallel</h3>
          <ul>
            <li><strong>When to use parallel streams?</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> CPU-bound + Large data + No side effects<br>
              🎯 <strong>Tip:</strong> Benchmark first! Overhead can hurt small datasets<br>
              ⚠️ <strong>Pitfall:</strong> Shared state, ordering issues, thread overhead</span></li>
            
            <li><strong>Null handling strategies</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> filter(Objects::nonNull) or Optional<br>
              🎯 <strong>Tip:</strong> Handle nulls early in the pipeline<br>
              ⚠️ <strong>Pitfall:</strong> NPE in map operations with null elements</span></li>
            
            <li><strong>Infinite streams</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> Stream.generate() or Stream.iterate()<br>
              🎯 <strong>Tip:</strong> Always use limit() with infinite streams<br>
              ⚠️ <strong>Pitfall:</strong> Without limit, stream runs forever</span></li>
            
            <li><strong>peek vs map</strong> <br>
              <span class="muted">💡 <strong>Memory:</strong> peek = debug, map = transform<br>
              🎯 <strong>Tip:</strong> Remove peek in production code<br>
              ⚠️ <strong>Pitfall:</strong> peek can cause side effects in parallel streams</span></li>
          </ul>
          
          <h3>🎯 Interview Success Tips</h3>
          <ul>
            <li><strong>Always mention:</strong> <span class="muted">Lazy evaluation, immutability, functional style</span></li>
            <li><strong>Show knowledge:</strong> <span class="muted">Primitive streams, collectors, parallel considerations</span></li>
            <li><strong>Common follow-ups:</strong> <span class="muted">Performance implications, alternative approaches</span></li>
          </ul>
        </div>
      </div>
      
      <!-- Interactive Quiz 3 -->
      <div class="quiz-container">
        <h3>⚡ Performance Quiz</h3>
        <div class="quiz-question">Which operations are short-circuiting in Stream API?</div>
        <div class="quiz-options">
          <div class="quiz-option" data-correct="false">map, filter, sorted</div>
          <div class="quiz-option" data-correct="true">limit, findFirst, anyMatch, allMatch</div>
          <div class="quiz-option" data-correct="false">collect, forEach, reduce</div>
          <div class="quiz-option" data-correct="false">distinct, skip, peek</div>
        </div>
        <div class="quiz-feedback">
          <p></p>
        </div>
      </div>
    </section>

    <!-- Coding Problems with Intuitions -->
    <section class="card">
      <h2>💻 Coding Practice – Memory Patterns</h2>
      <div class="grid cols-2">
        <div>
          <h3>🔥 Top Interview Problems</h3>
          <ol class="small">
            <li><strong>Second highest salary</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> sort desc → skip(1) → findFirst<br>
              🎯 <strong>Memory:</strong> "Skip the first, get the second"<br>
              <code>salaries.sorted(reverseOrder()).skip(1).findFirst()</code></span></li>
            
            <li><strong>Word frequency count</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> split → group → count<br>
              🎯 <strong>Memory:</strong> "Group and count"<br>
              <code>words.collect(groupingBy(identity(), counting()))</code></span></li>
            
            <li><strong>Filter + Sort + Map chain</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> filter → sort → map<br>
              🎯 <strong>Memory:</strong> "Filter first, then sort, then transform"<br>
              <code>emps.filter(age>30).sorted(byName).map(Emp::getName)</code></span></li>
            
            <li><strong>Find longest string</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> max with comparator<br>
              🎯 <strong>Memory:</strong> "Max with length comparator"<br>
              <code>strings.max(comparing(String::length))</code></span></li>
            
            <li><strong>Even/Odd partition</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> partitioningBy with predicate<br>
              🎯 <strong>Memory:</strong> "Partition by even/odd"<br>
              <code>numbers.collect(partitioningBy(n -> n % 2 == 0))</code></span></li>
          </ol>
        </div>
        
        <div>
          <h3>🚀 Advanced Patterns</h3>
          <ol class="small">
            <li><strong>Detect duplicates</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> size vs distinct count<br>
              🎯 <strong>Memory:</strong> "If sizes differ, there are duplicates"<br>
              <code>list.size() != list.distinct().count()</code></span></li>
            
            <li><strong>Flatten nested collections</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> flatMap with stream<br>
              🎯 <strong>Memory:</strong> "FlatMap flattens"<br>
              <code>lists.flatMap(List::stream)</code></span></li>
            
            <li><strong>First non-repeated character</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> group → filter → findFirst<br>
              🎯 <strong>Memory:</strong> "Group by char, find count=1"<br>
              <code>chars.collect(groupingBy(identity(), counting()))<br>
              .entrySet().stream().filter(e->e.getValue()==1).findFirst()</code></span></li>
            
            <li><strong>Average salary per department</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> group by + averaging<br>
              🎯 <strong>Memory:</strong> "Group by dept, average salary"<br>
              <code>emps.collect(groupingBy(Emp::getDept, averagingDouble(Emp::getSalary)))</code></span></li>
            
            <li><strong>Multi-level sorting</strong> <br>
              <span class="muted">💡 <strong>Pattern:</strong> comparing + thenComparing<br>
              🎯 <strong>Memory:</strong> "Compare first, then compare"<br>
              <code>emps.sorted(comparing(Emp::getSalary).thenComparing(Emp::getName))</code></span></li>
          </ol>
        </div>
      </div>
      
      <div class="card" style="margin-top: 16px; background: #0f172a; border: 1px solid #334155;">
        <h3>🎯 Quick Memory Tricks</h3>
        <div class="grid cols-3">
          <div>
            <strong>🔍 Finding Patterns:</strong><br>
            <span class="muted">• max/min → use max()/min() with comparator<br>
            • first/last → use findFirst()/reduce()<br>
            • count → use count() or collect(counting())</span>
          </div>
          <div>
            <strong>🔄 Transformation Patterns:</strong><br>
            <span class="muted">• 1→1 → map()<br>
            • 1→Many → flatMap()<br>
            • filter → keep matching elements</span>
          </div>
          <div>
            <strong>📊 Aggregation Patterns:</strong><br>
            <span class="muted">• group → groupingBy()<br>
            • partition → partitioningBy()<br>
            • collect → toList(), toSet(), toMap()</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Cheat Sheet Table -->
    <section class="card">
      <h2>📚 Stream Methods – Memory Cheat Sheet</h2>
      
      <!-- Quick Reference Cards -->
      <div class="grid cols-3" style="margin-bottom: 20px;">
        <div class="card" style="background: #0f172a; border: 1px solid #334155; padding: 12px;">
          <h4 style="color: #86efac; margin: 0 0 8px;">🔄 Intermediate Ops</h4>
          <div class="small">
            <strong>Memory:</strong> Lazy builders<br>
            <strong>Common:</strong> map, filter, sorted<br>
            <strong>Tip:</strong> Chain them together
          </div>
        </div>
        <div class="card" style="background: #0f172a; border: 1px solid #334155; padding: 12px;">
          <h4 style="color: #fca5a5; margin: 0 0 8px;">⚡ Terminal Ops</h4>
          <div class="small">
            <strong>Memory:</strong> Eager executors<br>
            <strong>Common:</strong> collect, forEach, reduce<br>
            <strong>Tip:</strong> End your pipeline
          </div>
        </div>
        <div class="card" style="background: #0f172a; border: 1px solid #334155; padding: 12px;">
          <h4 style="color: #fbbf24; margin: 0 0 8px;">🎯 Short-Circuiting</h4>
          <div class="small">
            <strong>Memory:</strong> Stop early<br>
            <strong>Ops:</strong> limit, findFirst, anyMatch<br>
            <strong>Tip:</strong> Performance boost
          </div>
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th>Method</th><th>Type</th><th>Memory Trick</th><th>When to Use</th><th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><code>map(Function)</code></td><td>Intermediate</td><td>🎯 1→1 transformer</td><td>Transform each element</td><td><code>emps.map(Emp::getName)</code></td></tr>
          <tr><td><code>flatMap(Function)</code></td><td>Intermediate</td><td>🎯 1→Many flattener</td><td>Flatten nested collections</td><td><code>lists.flatMap(List::stream)</code></td></tr>
          <tr><td><code>filter(Predicate)</code></td><td>Intermediate</td><td>🎯 Gatekeeper</td><td>Keep matching elements</td><td><code>emps.filter(e -&gt; e.getSal() &gt; 50_000)</code></td></tr>
          <tr><td><code>distinct()</code></td><td>Intermediate</td><td>🎯 Duplicate remover</td><td>Remove duplicates</td><td><code>list.distinct()</code></td></tr>
          <tr><td><code>sorted()</code></td><td>Intermediate</td><td>🎯 Natural orderer</td><td>Natural order</td><td><code>list.sorted()</code></td></tr>
          <tr><td><code>sorted(Comparator)</code></td><td>Intermediate</td><td>🎯 Custom orderer</td><td>Custom order</td><td><code>emps.sorted(comparing(Emp::getSal))</code></td></tr>
          <tr><td><code>peek(Consumer)</code></td><td>Intermediate</td><td>🎯 Debug spy</td><td>Debug/log (remove in prod)</td><td><code>list.peek(System.out::println)</code></td></tr>
          <tr><td><code>limit(n)</code></td><td>Intermediate</td><td>🎯 Top N selector</td><td>Top N / pagination</td><td><code>list.limit(5)</code></td></tr>
          <tr><td><code>skip(n)</code></td><td>Intermediate</td><td>🎯 Offset skipper</td><td>Offset / pagination</td><td><code>list.skip(10)</code></td></tr>
          <tr><td><code>mapToInt</code></td><td>Intermediate</td><td>🎯 Primitive converter</td><td>Numeric ops (no boxing)</td><td><code>emps.mapToInt(Emp::getAge)</code></td></tr>
          <tr><td><code>boxed()</code></td><td>Intermediate</td><td>🎯 Object wrapper</td><td>Back to objects</td><td><code>ints.boxed()</code></td></tr>
          <tr><td><code>parallel()</code></td><td>Intermediate</td><td>🎯 Speed booster</td><td>CPU‑bound, careful state</td><td><code>list.parallelStream()</code></td></tr>
          <tr><td><code>forEach(Consumer)</code></td><td>Terminal</td><td>🎯 Side-effect doer</td><td>Side‑effects per item</td><td><code>list.forEach(System.out::println)</code></td></tr>
          <tr><td><code>collect(Collector)</code></td><td>Terminal</td><td>🎯 Result gatherer</td><td>Gather results</td><td><code>toList(), groupingBy()</code></td></tr>
          <tr><td><code>reduce(BinaryOp)</code></td><td>Terminal</td><td>🎯 Single value maker</td><td>Aggregate single value</td><td><code>sum, max, concat</code></td></tr>
          <tr><td><code>count()</code></td><td>Terminal</td><td>🎯 Counter</td><td>Number of items</td><td><code>list.count()</code></td></tr>
          <tr><td><code>min/max(Comparator)</code></td><td>Terminal</td><td>🎯 Extrema finder</td><td>Extrema</td><td><code>max(comparing(...))</code></td></tr>
          <tr><td><code>findFirst/findAny()</code></td><td>Terminal</td><td>🎯 First/Any picker</td><td>Pick one (ordered/any)</td><td><code>findFirst()</code></td></tr>
          <tr><td><code>any/all/noneMatch</code></td><td>Terminal</td><td>🎯 Predicate checker</td><td>Predicate checks</td><td><code>anyMatch(p)</code></td></tr>
          <tr><td><code>toArray()</code></td><td>Terminal</td><td>🎯 Array converter</td><td>Array output</td><td><code>toArray(String[]::new)</code></td></tr>
        </tbody>
      </table>
      
      <div class="card" style="margin-top: 16px; background: #0f172a; border: 1px solid #334155;">
        <h3>🎯 Memory Patterns for Common Collectors</h3>
        <div class="grid cols-2">
          <div>
            <strong>📊 Grouping & Partitioning:</strong><br>
            <span class="muted">• groupingBy() → Group by key<br>
            • partitioningBy() → Split by predicate<br>
            • counting() → Count occurrences<br>
            • summingInt() → Sum integers</span>
          </div>
          <div>
            <strong>🔄 Collection Builders:</strong><br>
            <span class="muted">• toList() → ArrayList<br>
            • toSet() → HashSet<br>
            • toMap() → HashMap<br>
            • joining() → Concatenated string</span>
          </div>
        </div>
      </div>
      
      <p class="section-note small">💡 <strong>Pro Tips:</strong> Use primitive streams for performance, prefer collect() over reduce() for complex operations, and remember that intermediate ops are lazy!</p>
    </section>

    <!-- Real Interview Scenarios -->
    <section class="card">
      <h2>🎯 Real Interview Scenarios – Step-by-Step</h2>
      
      <div class="card" style="background: #0f172a; border: 1px solid #334155; margin-bottom: 16px;">
        <h3>🔥 Scenario 1: "Find the second highest salary from employee list"</h3>
        <div class="grid cols-2">
          <div>
            <strong>🎯 Interview Approach:</strong><br>
            <span class="muted">1. <strong>Clarify:</strong> "Should I handle duplicates?"<br>
            2. <strong>Think aloud:</strong> "I can sort and skip, or use distinct first"<br>
            3. <strong>Code:</strong> Show multiple approaches<br>
            4. <strong>Optimize:</strong> Discuss time/space complexity</span>
          </div>
          <div>
            <strong>💡 Memory Tricks:</strong><br>
            <span class="muted">• <strong>Skip Pattern:</strong> "Skip the first, get the second"<br>
            • <strong>Distinct First:</strong> "Remove duplicates, then skip"<br>
            • <strong>One-Pass:</strong> "Track max and second in one go"</span>
          </div>
        </div>
        <div style="margin-top: 12px;">
          <strong>🚀 Multiple Solutions:</strong><br>
          <code>// Approach 1: Sort + Skip (O(n log n))<br>
          salaries.sorted(reverseOrder()).skip(1).findFirst()<br><br>
          // Approach 2: Distinct + Skip (O(n log n))<br>
          salaries.distinct().sorted(reverseOrder()).skip(1).findFirst()<br><br>
          // Approach 3: One-pass reduce (O(n))<br>
          salaries.reduce(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}, (acc, sal) -> {<br>
          &nbsp;&nbsp;if (sal > acc[0]) { acc[1] = acc[0]; acc[0] = sal; }<br>
          &nbsp;&nbsp;else if (sal > acc[1] && sal != acc[0]) acc[1] = sal;<br>
          &nbsp;&nbsp;return acc; })[1]</code>
        </div>
      </div>

      <div class="card" style="background: #0f172a; border: 1px solid #334155; margin-bottom: 16px;">
        <h3>🔥 Scenario 2: "Group employees by department and find average salary"</h3>
        <div class="grid cols-2">
          <div>
            <strong>🎯 Interview Approach:</strong><br>
            <span class="muted">1. <strong>Understand:</strong> "Group by dept, then average salaries"<br>
            2. <strong>Choose collector:</strong> groupingBy + averagingDouble<br>
            3. <strong>Handle edge cases:</strong> Empty departments, null salaries<br>
            4. <strong>Discuss alternatives:</strong> Manual grouping vs streams</span>
          </div>
          <div>
            <strong>💡 Memory Tricks:</strong><br>
            <span class="muted">• <strong>Group + Average:</strong> "Group by key, average values"<br>
            • <strong>Collector Chain:</strong> "groupingBy + averagingDouble"<br>
            • <strong>Null Safety:</strong> "filter non-null first"</span>
          </div>
        </div>
        <div style="margin-top: 12px;">
          <strong>🚀 Solution:</strong><br>
          <code>// Basic approach<br>
          emps.collect(groupingBy(Emp::getDept, averagingDouble(Emp::getSalary)))<br><br>
          // With null safety<br>
          emps.filter(e -> e.getSalary() != null)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;.collect(groupingBy(Emp::getDept, averagingDouble(Emp::getSalary)))</code>
        </div>
      </div>

      <div class="card" style="background: #0f172a; border: 1px solid #334155;">
        <h3>🔥 Scenario 3: "Find the first non-repeated character in a string"</h3>
        <div class="grid cols-2">
          <div>
            <strong>🎯 Interview Approach:</strong><br>
            <span class="muted">1. <strong>Break down:</strong> "Count chars, find count=1"<br>
            2. <strong>Use streams:</strong> chars → group → filter → findFirst<br>
            3. <strong>Handle case:</strong> Case-sensitive or insensitive?<br>
            4. <strong>Edge cases:</strong> Empty string, all repeated</span>
          </div>
          <div>
            <strong>💡 Memory Tricks:</strong><br>
            <span class="muted">• <strong>Count Pattern:</strong> "Group by char, count occurrences"<br>
            • <strong>Filter Pattern:</strong> "Keep only count=1"<br>
            • <strong>Find Pattern:</strong> "Get the first one"</span>
          </div>
        </div>
        <div style="margin-top: 12px;">
          <strong>🚀 Solution:</strong><br>
          <code>// Step-by-step approach<br>
          str.chars()<br>
          &nbsp;&nbsp;.mapToObj(c -> (char) c)<br>
          &nbsp;&nbsp;.collect(groupingBy(identity(), counting()))<br>
          &nbsp;&nbsp;.entrySet().stream()<br>
          &nbsp;&nbsp;.filter(entry -> entry.getValue() == 1)<br>
          &nbsp;&nbsp;.map(Map.Entry::getKey)<br>
          &nbsp;&nbsp;.findFirst()</code>
        </div>
      </div>
    </section>

    <!-- Enhanced Patterns Section -->
    <section class="card">
      <h2>🎯 Advanced Patterns – Memory Mastery</h2>
      <div class="grid cols-2">
        <div>
          <h3>🔥 Common Interview Patterns</h3>
          <ol class="small">
            <li><strong>Second Highest (Multiple Ways)</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "Skip the first, get the second"<br>
              🎯 <strong>Approaches:</strong><br>
              • Sort DESC + skip(1) → O(n log n)<br>
              • Distinct + sort + skip → O(n log n)<br>
              • One-pass reduce → O(n)<br>
              • Set + remove max → O(n)</span></li>
            
            <li><strong>Word Frequency Counter</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "Group and count"<br>
              🎯 <strong>Pattern:</strong> split → groupBy → counting()<br>
              <code>words.collect(groupingBy(identity(), counting()))</code></span></li>
            
            <li><strong>Flatten Nested Collections</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "FlatMap flattens"<br>
              🎯 <strong>Pattern:</strong> flatMap with stream<br>
              <code>lists.flatMap(List::stream)</code></span></li>
          </ol>
        </div>
        
        <div>
          <h3>🚀 Performance Patterns</h3>
          <ol class="small">
            <li><strong>Primitive Stream Optimization</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "Primitives = No boxing"<br>
              🎯 <strong>Use:</strong> mapToInt/ToLong/ToDouble<br>
              <code>emps.mapToInt(Emp::getAge).sum()</code></span></li>
            
            <li><strong>Short-Circuiting Operations</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "Stop early for performance"<br>
              🎯 <strong>Ops:</strong> limit, findFirst, anyMatch<br>
              <code>stream.limit(10).findFirst()</code></span></li>
            
            <li><strong>Filter Before Map</strong><br>
              <span class="muted">💡 <strong>Memory:</strong> "Reduce elements first"<br>
              🎯 <strong>Pattern:</strong> filter → map (not map → filter)<br>
              <code>emps.filter(age>30).map(Emp::getName)</code></span></li>
          </ol>
        </div>
      </div>
    </section>
    <!-- Final Quick Reference -->
    <section class="card">
      <h2>🚀 Interview Success Checklist</h2>
      <div class="grid cols-2">
        <div>
          <h3>✅ Before the Interview</h3>
          <ul class="small">
            <li><strong>Memorize LIFT:</strong> Lazy Intermediate, Fast Terminal</li>
            <li><strong>Know the Big 3:</strong> map (1→1), flatMap (1→Many), filter (gatekeeper)</li>
            <li><strong>Practice Patterns:</strong> Second highest, word frequency, grouping</li>
            <li><strong>Understand Performance:</strong> Primitive streams, short-circuiting</li>
            <li><strong>Common Pitfalls:</strong> Stream consumed twice, null handling</li>
          </ul>
        </div>
        <div>
          <h3>🎯 During the Interview</h3>
          <ul class="small">
            <li><strong>Think Aloud:</strong> Explain your approach step by step</li>
            <li><strong>Ask Questions:</strong> Clarify requirements (duplicates, nulls, etc.)</li>
            <li><strong>Show Alternatives:</strong> Multiple solutions with trade-offs</li>
            <li><strong>Discuss Performance:</strong> Time/space complexity</li>
            <li><strong>Handle Edge Cases:</strong> Empty collections, null values</li>
          </ul>
        </div>
      </div>
      
      <div class="card" style="margin-top: 16px; background: #0f172a; border: 1px solid #334155;">
        <h3>🎯 Quick Memory Triggers</h3>
        <div class="grid cols-4">
          <div>
            <strong>🔄 Transform:</strong><br>
            <span class="muted">map = 1→1<br>flatMap = 1→Many</span>
          </div>
          <div>
            <strong>🔍 Filter:</strong><br>
            <span class="muted">filter = gatekeeper<br>distinct = duplicate remover</span>
          </div>
          <div>
            <strong>📊 Collect:</strong><br>
            <span class="muted">groupingBy = group<br>partitioningBy = split</span>
          </div>
          <div>
            <strong>⚡ Performance:</strong><br>
            <span class="muted">mapToInt = no boxing<br>limit = stop early</span>
          </div>
        </div>
      </div>
    </section>

    <section class="card small">
      <p class="muted">🚀 <strong>Interactive Learning Experience</strong> by Pradeep Kushwah · Java 17 & Spring Boot interviews · Master Stream API with interactive quizzes, live coding, and cinematic effects! ✨</p>
      <p class="muted small">💡 <strong>Pro Tip:</strong> Practice these patterns daily for 30 minutes before your interview. The memory tricks will become second nature!</p>
    </section>
  </main>

  <script>
    // Global state for tracking progress and achievements
    let userProgress = {
      quizzesCompleted: 0,
      totalQuizzes: 3,
      achievements: [],
      sectionsVisited: new Set()
    };

    // Initialize the interactive experience
    document.addEventListener('DOMContentLoaded', function() {
      createParticles();
      initializeQuizzes();
      initializeStreamVisualization();
      initializeProgressTracking();
      initializeScrollAnimations();
    });

    // Create animated background particles
    function createParticles() {
      const particlesContainer = document.getElementById('particles');
      const particleCount = 50;

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Random size and position
        const size = Math.random() * 4 + 2;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.top = Math.random() * 100 + '%';
        
        // Random animation delay
        particle.style.animationDelay = Math.random() * 6 + 's';
        particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
        
        particlesContainer.appendChild(particle);
      }
    }

    // Initialize quiz functionality
    function initializeQuizzes() {
      const quizContainers = document.querySelectorAll('.quiz-container');
      
      quizContainers.forEach((container, index) => {
        const options = container.querySelectorAll('.quiz-option');
        const feedback = container.querySelector('.quiz-feedback');
        
        options.forEach(option => {
          option.addEventListener('click', function() {
            if (this.classList.contains('selected')) return;
            
            // Remove previous selections
            options.forEach(opt => opt.classList.remove('selected'));
            this.classList.add('selected');
            
            // Check answer
            const isCorrect = this.dataset.correct === 'true';
            
            // Show feedback
            const feedbackText = feedback.querySelector('p');
            if (isCorrect) {
              feedbackText.textContent = '🎉 Correct! Great job!';
              feedback.className = 'quiz-feedback correct show';
              this.classList.add('correct');
              
              // Award achievement
              awardAchievement('Quiz Master', 'Completed a quiz correctly!');
            } else {
              feedbackText.textContent = '❌ Not quite right. Try again!';
              feedback.className = 'quiz-feedback incorrect show';
              this.classList.add('incorrect');
              
              // Show correct answer
              options.forEach(opt => {
                if (opt.dataset.correct === 'true') {
                  opt.classList.add('correct');
                }
              });
            }
            
            // Update progress
            if (isCorrect && !userProgress.sectionsVisited.has(`quiz-${index}`)) {
              userProgress.quizzesCompleted++;
              userProgress.sectionsVisited.add(`quiz-${index}`);
              updateProgress();
            }
          });
        });
      });
    }

    // Initialize stream visualization
    function initializeStreamVisualization() {
      const streamSteps = document.querySelectorAll('.stream-step');
      let currentStep = 0;
      
      streamSteps.forEach((step, index) => {
        step.addEventListener('click', function() {
          // Remove active class from all steps
          streamSteps.forEach(s => s.classList.remove('active'));
          
          // Add active class to current and previous steps
          for (let i = 0; i <= index; i++) {
            streamSteps[i].classList.add('active');
          }
          
          // Animate the step
          this.style.transform = 'scale(1.05)';
          setTimeout(() => {
            this.style.transform = '';
          }, 200);
          
          // Award achievement for interaction
          if (index === streamSteps.length - 1) {
            awardAchievement('Stream Master', 'Completed the stream visualization!');
          }
        });
      });
    }

    // Initialize progress tracking
    function initializeProgressTracking() {
      updateProgress();
      
      // Track section visits
      const sections = document.querySelectorAll('section');
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const sectionId = entry.target.querySelector('h2')?.textContent || 'unknown';
            userProgress.sectionsVisited.add(sectionId);
            updateProgress();
          }
        });
      }, { threshold: 0.5 });
      
      sections.forEach(section => observer.observe(section));
    }

    // Initialize scroll animations
    function initializeScrollAnimations() {
      const cards = document.querySelectorAll('.card');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.style.animation = 'fadeInUp 0.6s ease-out';
          }
        });
      }, { threshold: 0.1 });
      
      cards.forEach(card => observer.observe(card));
    }

    // Update progress bar and text
    function updateProgress() {
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      
      const totalSections = 6; // Approximate number of main sections
      const visitedSections = userProgress.sectionsVisited.size;
      const quizProgress = (userProgress.quizzesCompleted / userProgress.totalQuizzes) * 0.3;
      const sectionProgress = (visitedSections / totalSections) * 0.7;
      
      const totalProgress = Math.min(100, (quizProgress + sectionProgress) * 100);
      
      progressFill.style.width = totalProgress + '%';
      progressText.textContent = Math.round(totalProgress) + '% Complete';
      
      // Award achievements based on progress
      if (totalProgress >= 25 && !userProgress.achievements.includes('Getting Started')) {
        awardAchievement('Getting Started', 'Completed 25% of the learning material!');
      }
      if (totalProgress >= 50 && !userProgress.achievements.includes('Halfway There')) {
        awardAchievement('Halfway There', 'Completed 50% of the learning material!');
      }
      if (totalProgress >= 100 && !userProgress.achievements.includes('Stream Master')) {
        awardAchievement('Stream Master', 'Completed the entire learning experience!');
      }
    }

    // Award achievements
    function awardAchievement(title, description) {
      if (userProgress.achievements.includes(title)) return;
      
      userProgress.achievements.push(title);
      
      const popup = document.getElementById('achievementPopup');
      const text = document.getElementById('achievementText');
      
      text.textContent = `${title}: ${description}`;
      popup.classList.add('show');
      
      // Add to achievements list
      const achievementsList = document.getElementById('achievements');
      const achievementItem = document.createElement('div');
      achievementItem.className = 'achievement-item';
      achievementItem.innerHTML = `🏆 ${title}`;
      achievementsList.appendChild(achievementItem);
      
      // Hide popup after 3 seconds
      setTimeout(() => {
        popup.classList.remove('show');
      }, 3000);
    }

    // Code playground functionality
    function runCode() {
      const codeEditor = document.getElementById('codeEditor');
      const output = document.getElementById('codeOutput');
      
      // Simulate code execution (in a real implementation, you'd use a Java execution service)
      const code = codeEditor.value;
      
      // Simple simulation based on the code content
      if (code.includes('filter') && code.includes('map') && code.includes('collect')) {
        output.textContent = 'Names: [Bob, Charlie, Diana]\n\n✅ Code executed successfully!\n💡 Try modifying the filter condition or adding more operations.';
        output.style.color = '#22c55e';
        
        awardAchievement('Code Runner', 'Successfully executed code in the playground!');
      } else {
        output.textContent = '❌ Code execution failed. Please check your syntax.\n💡 Make sure to include proper imports and valid Java syntax.';
        output.style.color = '#ef4444';
      }
      
      // Animate the output
      output.style.animation = 'slideIn 0.3s ease';
    }

    // Add keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Ctrl/Cmd + Enter to run code
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        const codeEditor = document.getElementById('codeEditor');
        if (document.activeElement === codeEditor) {
          runCode();
        }
      }
      
      // Space to advance through stream steps
      if (e.key === ' ' && e.target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        const activeStep = document.querySelector('.stream-step.active');
        if (activeStep) {
          const nextStep = activeStep.nextElementSibling;
          if (nextStep && nextStep.classList.contains('stream-step')) {
            nextStep.click();
          }
        }
      }
    });

    // Add smooth scrolling for navigation
    document.querySelectorAll('h2').forEach(heading => {
      heading.addEventListener('click', function() {
        this.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });

    // Add hover effects for interactive elements
    document.querySelectorAll('code').forEach(code => {
      code.addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.05)';
        this.style.boxShadow = '0 0 10px rgba(96,165,250,0.3)';
      });
      
      code.addEventListener('mouseleave', function() {
        this.style.transform = '';
        this.style.boxShadow = '';
      });
    });

    // Add click effects for cards
    document.querySelectorAll('.card').forEach(card => {
      card.addEventListener('click', function(e) {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A') {
          this.style.transform = 'scale(1.02)';
          setTimeout(() => {
            this.style.transform = '';
          }, 200);
        }
      });
    });

    // Initialize tooltips for memory tricks
    document.querySelectorAll('.tag').forEach(tag => {
      tag.addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.1) translateY(-2px)';
      });
      
      tag.addEventListener('mouseleave', function() {
        this.style.transform = '';
      });
    });

    // Add loading animation
    window.addEventListener('load', function() {
      document.body.style.opacity = '0';
      document.body.style.transition = 'opacity 0.5s ease';
      
      setTimeout(() => {
        document.body.style.opacity = '1';
      }, 100);
    });

    // Add performance monitoring
    let performanceMetrics = {
      startTime: Date.now(),
      interactions: 0
    };

    document.addEventListener('click', function() {
      performanceMetrics.interactions++;
    });

    // Show completion message
    setTimeout(() => {
      if (userProgress.quizzesCompleted === userProgress.totalQuizzes) {
        awardAchievement('Quiz Champion', 'Completed all quizzes! You\'re ready for your interview!');
      }
    }, 5000);
  </script>
</body>
</html>
